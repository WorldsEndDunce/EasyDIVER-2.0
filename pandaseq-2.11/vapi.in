/* vim: set filetype=vala: */
/**
 * PANDAseq @VERSION@ Illumina assembler
 *
 * Assemble paired FASTQ Illumina reads and strip the region between amplification primers.
 */
[CCode (cheader_filename = "pandaseq.h")]
namespace Panda {
	/**
	 * Codes used for logging conditions during the assembly
	 *
	 * Some of these are errors and some are informational.
	 */
	[CCode (cname = "PandaCode", has_type_id = false, cprefix = "PANDA_CODE_")]
	public enum Code {
		/**
		 * Invalid character in nucleotide data
		 */
		BAD_NT,
		/**
		 * The best computed overlap
		 */
		BEST_OVERLAP,
		/**
		 * A nucleotide copied during reconstruction of the forward sequence
		 */
		BUILD_FORWARD,
		/**
		 * A nucleotide determined during reconstruction of the overlap region
		 */
		BUILD_OVERLAP,
		/**
		 * A nucleotide copied during reconstruction of the reverse sequence
		 */
		BUILD_REVERSE,
		/**
		 * A //k//-mer found in the forward sequence
		 */
		FORWARD_KMER,
		/**
		 * An incorrect Illumina FASTQ header
		 */
		ID_PARSE_FAILURE,
		/**
		 * The //k//-mer table is too small for the sequence
		 */
		INSUFFICIENT_KMER_TABLE,
		/**
		 * A //k//-mer is thrown away due to a collision
		 */
		LOST_KMER,
		/**
		 * A reconstruction is rejected because the quality score is below threshold
		 */
		LOW_QUALITY_REJECT,
		/**
		 * A pair of bases disagree in the reconstruction
		 */
		MISMATCHED_BASE,
		/**
		 * Display information about a module
		 */
		MOD_INFO,
		/**
		 * The computed sequence length is invalid
		 */
		NEGATIVE_SEQUENCE_LENGTH,
		/**
		 * No sequence data is availble in the file
		 */
		NO_DATA,
		/**
		 * The file could not be opened
		 */
		NO_FILE,
		/**
		 * The forward primer cannot be found in the sequence
		 */
		NO_FORWARD_PRIMER,
		/**
		 * The quality information is missing in the FASTQ file
		 */
		NO_QUALITY_INFO,
		/**
		 * The reverse primer cannot be found in the sequence
		 */
		NO_REVERSE_PRIMER,
		/**
		 * The Illumina headers from the forward and reverse sequences do not match
		 */
		NOT_PAIRED,
		/**
		 * A possible overlap has been determined
		 */
		OVERLAP_POSSIBILITY,
		/**
		 * Error parsing FASTQ data
		 */
		PARSE_FAILURE,
		/**
		 * An input file ended in the middle of a FASTQ file
		 */
		PREMATURE_EOF,
		/**
		 * The input read is longer than {@link MAX_LEN}
		 */
		READ_TOO_LONG,
		/**
		 * Reconstruction will commence with provided parameters
		 */
		RECONSTRUCTION_PARAM,
		/**
		 * The number of sequences rejected by a particular module
		 * @see Assembler.module_stats
		 */
		REJECT_STAT,
		/**
		 * A //k//-mer found in the reverse sequence
		 */
		REVERSE_KMER,
		/**
		 * The reconsructed sequence will exceed the memory buffer
		 */
		SEQUENCE_TOO_LONG,
		/**
		 * The PHRED offset should probably be 64, not 33.
		 */
		PHRED_OFFSET;
		[CCode (cname = "panda_code_str")]
		public unowned string to_string ();
	}
	/**
	 * Decide what kinds of messages are passed to the logger.
	 */
	[CCode (cname = "PandaDebug", has_type_id = false, cprefix = "PANDA_DEBUG_")]
	[Flags]
	public enum Debug {
		/**
		 * Usual output about assembly.
		 */
		BUILD,
		/**
		 * Input processing-related errors.
		 */
		FILE,
		/**
		 * Extra statistics.
		 */
		STAT,
		/**
		 * Information about building the //k//-mer table (long and boring).
		 */
		KMER,
		/**
		 * Excruciating detail about the reconstruction.
		 */
		RECON,
		/**
		 * Bucket loads of data about mistatches.
		 */
		MISMATCH,
		DEFAULT;
		[CCode (cname = "panda_debug_flags &= ~")]
		public void disable ();
		[CCode (cname = "panda_debug_flags |= ")]
		public void enable ();
		[CCode (cname = "panda_debug_flags = ")]
		public void set ();
	}

	/**
	 * FASTQ header format
	 */
	[CCode (cname = "PandaIdFmt", has_type_id = false, cprefix = "PANDA_IDFMT_")]
	public enum IdFormat {
		UNKNOWN,
		SRA,
		CASAVA_1_4,
		CASAVA_1_7,
		EBI_SRA;
		[CCode (cname = "panda_idfmt_has_direction")]
		public bool has_direction ();
		[CCode (cname = "panda_idfmt_str")]
		public unowned string to_string ();
	}

	/**
	 * A single nucleotide
	 */
	[CCode (cname = "panda_nt", has_type_id = false, cprefix = "PANDA_NT_")]
	[Flags]
	public enum Nt {
		/**
		 * Nothing
		 */
		Z,
		/**
		 * Adenine
		 */
		A,
		/**
		 * Cytosine
		 */
		C,
		/**
		 * Guanine
		 */
		G,
		/**
		 * Thyamine
		 */
		T;
		/**
		 * Is nucleotide degenerate?
		 */
		[CCode (cname = "PANDA_NT_IS_DEGN")]
		public bool is_degenerate ();
		/**
		 * Is nucleotide all possible values?
		 */
		[CCode (cname = "PANDA_NT_IS_N")]
		public bool is_n ();
		/**
		 * Get the nucleotide code for an ASCII character in IUPAC
		 */
		[CCode (cname = "panda_nt_from_ascii")]
		public static Nt from_ascii (char c);
		/**
		 * Get the complement nucleotide code for an ASCII character in IUPAC
		 */
		[CCode (cname = "panda_nt_from_ascii_complement")]
		public static Nt from_ascii_complement (char c);
		/**
		 * Get the complementary nucleotide.
		 */
		[CCode(cname = "panda_nt_complement")]
		public Nt complement();
		/**
		 * Convert a nucleotide to an IUPAC representation
		 */
		[CCode (cname = "panda_nt_to_ascii")]
		public char to_ascii ();
	}
	/**
	 * The policy for Illumina tags/barcodes in sequence names.
	 */
	[CCode (cname = "PandaTagging", has_type_id = false, cprefix = "PANDA_TAG_")]
	public enum Tagging {
		/**
		 * The parsing should return an error if the sequence does not have a tag.
		 */
		PRESENT,
		/**
		 * The parsing should return an error if the sequence has a tag.
		 */
		ABSENT,
		/**
		 * The parsing should not care if the sequence a tag.
		 */
		OPTIONAL,
	}

	[CCode (cname = "panda_algorithm", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
	[Compact]
	public class Algorithm {
		[CCode (cname = "panda_algorithm_ea_util", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class EAUtil : Algorithm {
			/**
			 * Create a FastqJoin algorithm from the EA utils package.
			 */
			[CCode (cname = "panda_algorithm_ea_util_new")]
			public EAUtil ();
		}
		[CCode (cname = "panda_algorithm_flash", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class Flash : Algorithm {
			/**
			 * Create a Flash algorithm.
			 */
			[CCode (cname = "panda_algorithm_flash_new")]
			public Flash ();
		}
		[CCode (cname = "panda_algorithm_pear", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class Pear : Algorithm {
			/**
			 * The log probability of a random base match.
			 */
			double random_base_log_p {
				[CCode (cname = "panda_algorithm_pear_get_random_base_log_p")]
				get;
				[CCode (cname = "panda_algorithm_pear_set_random_base_log_p")]
				set;
			}

			/**
			 * Create a PEAR algorithm.
			 */
			[CCode (cname = "panda_algorithm_pear_new")]
			public Pear ();
		}
		[CCode (cname = "panda_algorithm_rdp_mle", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class RdpMle : Algorithm {
			/**
			 * Create a RDP MLE algorithm.
			 */
			[CCode (cname = "panda_algorithm_rdp_mle_new")]
			public RdpMle ();
		}

		[CCode (cname = "panda_algorithm_simple_bayes", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class SimpleBayes : Algorithm {
			/**
			 * The minimum error estimation in the sequence data (epsilon)
			 */
			public double error_estimation {
				[CCode (cname = "panda_algorithm_simple_bayes_get_error_estimation")]
				get;
				[CCode (cname = "simple_bayes_set_error_estimation")]
				set;
			}

			/**
			 * Create a simple Bayesian algorithm.
			 */
			[CCode (cname = "panda_algorithm_simple_bayes_new")]
			public SimpleBayes ();
		}
		[CCode (cname = "panda_algorithm_stitch", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class Stitch : Algorithm {
			/**
			 * Create a Stitch algorithm.
			 */
			[CCode (cname = "panda_algorithm_stitch_new")]
			public Stitch ();
		}

		[CCode (cname = "panda_algorithm_uparse", ref_function = "panda_algorithm_ref", unref_function = "panda_algorithm_unref")]
		public class UParse : Algorithm {
			/**
			 * The minimum error estimation in the sequence data (epsilon)
			 */
			public double error_estimation {
				[CCode (cname = "panda_algorithm_uparse_get_error_estimation")]
				get;
				[CCode (cname = "uparse_set_error_estimation")]
				set;
			}

			/**
			 * Create an UParse algorithm.
			 */
			[CCode (cname = "panda_algorithm_uparse_new")]
			public UParse ();
		}

		/**
		 * Compute the log probability of bases matching or mismatching with the supplied PHRED scores.
		 */
		[CCode (cname = "panda_algorithm_quality_compare")]
		public double compare (qual one, qual other);

		/**
		 * Checks if an algorithm is a member of a particular class.
		 */
		[CCode (cname = "PANDA_ALGORITHM_IS_A", generic_type_pos = 1.1)]
		public bool is_a<T> ();

		/**
		 * Increase the reference count on an algorithm.
		 */
		[CCode (cname = "panda_algorithm_ref")]
		public void @ref ();

		/**
		 * Decrease the reference count on an algorithm.
		 */
		[CCode (cname = "panda_algorithm_unref")]
		public void unref ();
	}
	/**
	 * The manager for an assembly
	 */
	[CCode (cname = "struct panda_assembler", ref_function = "panda_assembler_ref", unref_function = "panda_assembler_unref")]
	[Compact]
	public class Assembler {
		/**
		 * The algorithm used in overlap selection.
		 */
		public Algorithm algorithm {
			[CCode (cname = "panda_assembler_get_algorithm")]
			get;
			[CCode (cname = "panda_assembler_set_algorithm")]
			set;
		}
		/**
		 * The number of sequences rejected because the reads are unsatisfactory in some way.
		 */
		public long bad_read_count {
			[CCode (cname = "panda_assembler_get_bad_read_count")]
			get;
		}

		/**
		 * The number of sequences processed so far.
		 */
		public long count {
			[CCode (cname = "panda_assembler_get_count")]
			get;
		}

		/**
		 * The number of sequences rejected because the overlap could not be determined.
		 */
		public long failed_alignment_count {
			[CCode (cname = "panda_assembler_get_failed_alignment_count")]
			get;
		}

		/**
		 * The forward primer sequence to be stripped
		 *
		 * This is mutually exclusive with {@link forward_trim}
		 */
		public Nt[]? forward_primer {
			[CCode (cname = "panda_assembler_get_forward_primer")]
			get;
			[CCode (cname = "panda_assembler_set_forward_primer")]
			set;
		}

		/**
		 * The amount of forward sequence to strip
		 *
		 * This is mutually exclusive with {@link forward_primer}
		 */
		public size_t forward_trim {
			[CCode (cname = "panda_assembler_get_forward_trim")]
			get;
			[CCode (cname = "panda_assembler_set_forward_trim")]
			set;
		}

		public LogProxy logger {
			[CCode (cname = "panda_assembler_get_logger")]
			get;
		}

		/**
		 * The number of sequences rejected because the quality score is too low.
		 */
		public long low_quality_count {
			[CCode (cname = "panda_assembler_get_low_quality_count")]
			get;
		}

		/**
		 * The maximum overlap two sequences must have to be accepted.
		 */
		public int maximum_overlap {
			[CCode (cname = "panda_assembler_get_maximum_overlap")]
			get;
			[CCode (cname = "panda_assembler_set_maximum_overlap")]
			set;
		}

		/**
		 * The minimum overlap two sequences must have to be accepted. It must be greater than one.
		 */
		public int minimum_overlap {
			[CCode (cname = "panda_assembler_get_minimum_overlap")]
			get;
			[CCode (cname = "panda_assembler_set_minimum_overlap")]
			set;
		}

		/**
		 * The assembler's name in logging output.
		 */
		public string? name {
			[CCode (cname = "panda_assembler_get_name")]
			get;
			[CCode (cname = "panda_assembler_set_name")]
			set;
		}

		/**
		 * The number of sequences rejected because the forward primer could not be aligned.
		 */
		public long no_forward_primer_count {
			[CCode (cname = "panda_assembler_get_no_forward_primer_count")]
			get;
		}

		/**
		 * The number of sequences rejected because the reverse primer could not be aligned.
		 */
		public long no_reverse_primer_count {
			[CCode (cname = "panda_assembler_get_no_reverse_primer_count")]
			get;
		}

		/**
		 * The size of the k-mer table in this assembler.
		 */
		public size_t num_kmer {
			[CCode (cname = "panda_assembler_get_num_kmer")]
			get;
		}

		/**
		 * The number of sequences accepted.
		 */
		public long ok_count {
			[CCode (cname = "panda_assembler_get_ok_count")]
			get;
		}

		/**
		 * The distribution of overlaps produced so far.
		 */
		public Overlaps overlaps {
			[CCode (cname = "")]
			get;
		}

		/**
		 * Whether to strip the primers before or after assembly.
		 *
		 * Stripping before is faster, but means that there can be no primer sequence in the opposite read.
		 */
		public bool primers_after {
			[CCode (cname = "panda_assembler_get_primers_after")]
			get;
			[CCode (cname = "panda_assembler_set_primers_after")]
			set;
		}

		/**
		 * The penalty for moving the primer down the window.
		 */
		public double primer_penalty {
			[CCode (cname = "panda_assembler_get_primer_penalty")]
			get;
			[CCode (cname = "panda_assembler_set_primer_penalty")]
			set;
		}
		/**
		 * The reverse primer sequence to be stripped
		 *
		 * This is mutually exclusive with {@link reverse_trim}
		 */
		public Nt[]? reverse_primer {
			[CCode (cname = "panda_assembler_get_reverse_primer")]
			get;
			[CCode (cname = "panda_assembler_set_reverse_primer")]
			set;
		}

		/**
		 * The amount of reverse sequence to strip
		 *
		 * This is mutually exclusive with {@link reverse_primer}
		 */
		public size_t reverse_trim {
			[CCode (cname = "panda_assembler_get_reverse_trim")]
			get;
			[CCode (cname = "panda_assembler_set_reverse_trim")]
			set;
		}

		/**
		 * The numer of sequences where all possible overlaps had to be examined, instead of a quick hashing.
		 */
		public long slow_count {
			[CCode (cname = "panda_assembler_get_slow_count")]
			get;
		}
		/**
		 * The minimum quality threshold to have an assembly accepted. Must be between 0 and 1, exclusive.
		 */
		public double threshold {
			[CCode (cname = "panda_assembler_get_threshold")]
			get;
			[CCode (cname = "panda_assembler_set_threshold")]
			set;
		}

		/**
		 * Open a pair of bzipped for assembly.
		 *
		 * @see create_fastq_reader
		 */
		[CCode (cname = "panda_assembler_open_bz2")]
		public static Assembler? open_bz2 (string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

		/**
		 * Open a pair of FASTQ files for assembly.
		 *
		 * File may be plain text, or compressed with gzip or bzip2.
		 *
		 * @see create_fastq_reader
		 */
		[CCode (cname = "panda_assembler_open")]
		public static Assembler? open (string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

		/**
		 * Create a new assembler from a sequence source.
		 *
		 * @param next the function to call to get the next sequence. The assembler does not manage the memory of the returned arrays, but assume it may use them until the next call or destruction. If not provided, you may use {@link assemble} but not {@link next}
		 * @param logger the function to call to report information to the user.
		 */
		[CCode (cname = "panda_assembler_new")]
		public Assembler (owned NextSeq? next, LogProxy logger);

		/**
		 * Create a new assembler from a sequence source with a custom //k//-mer table size.
		 *
		 * @param num_kmers the number of sequence locations for a particular //k//-mer. This should be small (no more than 10), or the //k//-mer table will be extremely large.
		 * @see Assembler
		 */
		[CCode (cname = "panda_assembler_new_kmer")]
		public Assembler.kmer (owned NextSeq? next, LogProxy logger, size_t num_kmers = 2);

		/**
		 * Create a new assembler for given to FASTQ streams.
		 * @see create_fastq_reader
		 */
		[CCode (cname = "panda_assembler_new_fastq_reader")]
		public Assembler.fastq (owned BufferRead forward, owned BufferRead reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);

		/**
		 * Assemble a single sequence pair not drawn from the sequence stream.
		 *
		 * This works exactly like {@link next}, but instead of asking the {@link NextSeq} for the data, it expects this information to be provided.
		 */
		[CCode (cname = "panda_assembler_assemble")]
		public unowned result_seq? assemble (identifier id, qual[] forward, qual[] reverse);

		/**
		 * Add a module to this assembly process.
		 *
		 * Sequences will be checked using this module.
		 * @return true if the module was successfully initialised and added
		 */
		[CCode (cname = "panda_assembler_add_module")]
		public bool add_module (Module module);

		/**
		 * Add a collection of modules to this assembly process.
		 * @return the index of the last successfully added module
		 */
		[CCode (cname = "panda_assembler_add_modules")]
		public size_t add_modules ([CCode (array_length_type = "size_t")] Module[] modules);

		/**
		 * Clone the configuration of one assembler to another.
		 *
		 * This does not affect the sequence source or logging. Only the primers, trimming, and modules. The recorded statistics are separate.
		 */
		[CCode (cname = "panda_assembler_copy_configuration")]
		public void copy_configuration (Assembler src);

		/**
		 * Review all the modules associated with an assembler.
		 * @return true if callback has seen each module
		 */
		[CCode (cname = "panda_assembler_foreach_module")]
		public bool for_each_module (ModuleCallback callback);

		/**
		 * Log the number of sequences rejected by each module.
		 */
		[CCode (cname = "panda_assembler_module_stats")]
		public void module_stats ();

		/**
		 * Assemble the next sequence from the input
		 *
		 * This function will process sequences until one is assembled successfully or no more sequences are available from the input stream, after which it will return null.
		 * The returned sequence becomes invalid after the next call.
		 */
		[CCode (cname = "panda_assembler_next")]
		public unowned result_seq? next ();

		/**
		 * Increment reference count.
		 */
		[CCode (cname = "panda_assembler_ref")]
		public unowned Assembler @ref ();
		/**
		 * Attached a callback for every sequence that fails to have an overlap.
		 *
		 * This will be called when a sequence fails to have an overlap computed. This does not include sequences that are missing primers or sequences that are assembled and discarded by modules.
		 */
		[CCode (cname = "panda_assembler_set_fail_alignment")]
		public void set_fail_alignment (owned FailAlign? handler);
		/**
		 * Decrement reference count.
		 */
		[CCode (cname = "panda_assembler_unref")]
		public void unref ();
	}

	/**
	 * Iterate over a sequence presenting all //k//-mers without ''N''s or other denegerate bases.
	 */
	[CCode (cname = "struct panda_iter", free_function = "panda_iter_free")]
	[Compact]
	public class Iterator {
		/**
		 * The number of useful bits in the output.
		 */
		public size_t bits {
			[CCode (cname = "panda_iter_bits")]
			get;
		}
		/**
		 * The //k//-mer length.
		 */
		public int k {
			[CCode (cname = "panda_iter_k")]
			get;
		}

		/**
		 * Create an iterator over a sequence of nucleotides.
		 * @param seq the sequence to iterate over. This sequence must not be freed during the life of the iterator.
		 * @param reverse true to iterate from the end of the sequence rather than the beginning
		 * @param k the length of the output words. This must range between 1 and 4 * sizeof(size_t). Any other values will be converted to the standard //k//-mer length of 8.
		 */
		[CCode (cname = "panda_iterate_nt")]
		public Iterator.nt ([CCode (array_length_type = "size_t")] Nt[] seq, bool reverse = false, int k = 0);
		/**
		 * Iterate over probability-annotated sequence.
		 * @see Iterator.Iterator.nt
		 */
		[CCode (cname = "panda_iterate_qual")]
		public Iterator.qual ([CCode (array_length_type = "size_t")] qual[] seq, bool reverse = false, int k = 0);
		/**
		 * Iterate over probability-annotated sequence.
		 * @see Iterator.Iterator.nt
		 */
		[CCode (cname = "panda_iterate_result")]
		public Iterator.result ([CCode (array_length_type = "size_t")] result[] seq, bool reverse = false, int k = 0);

		/**
		 * Copy an iterator to a new one, preserving its current state.
		 */
		[CCode (cname = "panda_iter_dup")]
		public Iterator iterator ();
		/**
		 * Advance to the next position in the sequence.
		 * @return if null, there are no more //k//-mers in the sequence
		 */
		[CCode (cname = "panda_iter_next")]
		public unowned kmer? next ();
		/**
		 * Set an iterator back to the beginning of the sequence.
		 */
		[CCode (cname = "panda_iter_reset")]
		public void reset ();
	}
	[CCode (cname = "struct panda_linebuf", free_function = "panda_linebuf_free")]
	[Compact]
	public class LineBuf {
		/**
		 * Create a new line reader from a buffer reading source.
		 */
		[CCode (cname = "panda_linebuf_new")]
		public LineBuf (owned BufferRead read);
		/**
		 * Read the next line.
		 * @return the next line in the file. This is only valid until the next call.
		 */
		[CCode (cname = "panda_linebuf_next")]
		public unowned string? next_value ();
	}
	/**
	 * Logging proxy
	 */
	[CCode (cname = "struct panda_log_proxy", ref_function = "panda_log_proxy_ref", unref_function = "panda_log_proxy_unref")]
	[Compact]
	public class LogProxy {
		/**
		 * Open a file for writing error messages.
		 * @param filename The file to write.
		 * @param bzip Write BZipped text rather than plain text.
		 */
		[CCode (cname = "panda_log_proxy_open_file")]
		public static LogProxy? open_file (string filename, bool bzip);

		/**
		 * Create a new proxy with a callback.
		 */
		[CCode (cname = "panda_log_proxy_new")]
		public LogProxy (Writer writer);
		/**
		 * Write the log to an open file.
		 */
		[CCode (cname = "panda_log_proxy_new_file")]
		public LogProxy.file (owned GLib.FileStream file);
		/**
		 * Create a new proxy to standard error.
		 */
		[CCode (cname = "panda_log_proxy_new_stderr")]
		public LogProxy.stderr ();

		public Writer writer {
			[CCode (cname = "panda_log_proxy_get_writer")]
			get;
		}

		/**
		 * Writes an error message to the log with the same semantics as the POSIX perror function.
		 */
		[CCode (cname = "panda_log_proxy_perror")]
		public void perror (string? prefix);

		/**
		 * Increase the reference count on a proxy.
		 */
		[CCode (cname = "panda_log_proxy_ref")]
		public unowned LogProxy @ref ();
		/**
		 * Decrease the reference count on a proxy.
		 */
		[CCode (cname = "panda_log_proxy_unref")]
		public void unref ();

		/**
		 * Print a message to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_write")]
		public void write (Code code, Assembler? assembler, identifier? id, string message);

		/**
		 * Put a printf-like message in the log.
		 */
		[CCode (cname = "panda_log_proxy_write_f")]
		[PrintfFormat]
		public void write_f (string format, ...);

		/**
		 * Print the overlap histogram of an assember to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_write_overlap")]
		public void write_overlap (Assembler assembler);

		/**
		 * Print a string to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_write_str")]
		public void write_str (string str);

		/**
		 * Print a double with a STAT header to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_stat_double")]
		public void stat_double (Assembler assembler, string name, double @value);

		/**
		 * Print a double with a STAT header to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_stat_long")]
		public void stat_long (Assembler assembler, string name, long @value);

		/**
		 * Print a size_t with a STAT header to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_stat_size_t")]
		public void stat_size_t (Assembler assembler, string name, size_t @value);

		/**
		 * Print a string with a STAT header to the log.
		 *
		 * This method is thread-safe.
		 */
		[CCode (cname = "panda_log_proxy_stat_str")]
		public void stat_str (Assembler assembler, string name, string @value);
	}

	/**
	 * Sequence validity checker
	 */
	[CCode (cname = "struct panda_module", ref_function = "panda_module_ref", unref_function = "panda_module_unref")]
	public class Module {
		/**
		 * The current module API version
		 */
		[CCode (cname = "PANDA_API")]
		public const int API;

		/**
		 * The API version of a module.
		 *
		 * This is only appropriate for loaded modules. Modules constructed by {@link create} will always return {@link API}.
		 */
		public int api {
			[CCode (cname = "panda_module_get_api")]
			get;
		}

		/**
		 * The description of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? description {
			[CCode (cname = "panda_module_get_description")]
			get;
		}

		/**
		 * The name of a module.
		 */
		public string name {
			[CCode (cname = "panda_module_get_name")]
			get;
		}

		/**
		 * The usage information (i.e., help text) of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? usage {
			[CCode (cname = "panda_module_get_usage")]
			get;
		}

		/**
		 * The version of a module.
		 *
		 * This is only appropriate for loaded modules.
		 */
		public string? version {
			[CCode (cname = "panda_module_get_version")]
			get;
		}

		/**
		 * Check a sequence after reconstruction for validity.
		 */
		[CCode (cname = "PandaCheck", has_target = false, simple_generics = true)]
		public delegate bool Check<T> (LogProxy logger, result_seq sequence, T data);
		/**
		 * Check a sequence before reconstruction for validity.
		 */
		[CCode (cname = "PandaPreCheck", has_target = false, simple_generics = true)]
		public delegate bool PreCheck<T> (LogProxy logger, identifier id, qual[] forward, qual[] reverse, T data);

		/**
		 * Create a module given sequence checking parameters.
		 *
		 * @param name the name of the module, for user interaction
		 * @param check the check function, which must not be null
		 * @param precheck an optional check to be done before the module
		 */
		[CCode (cname = "panda_module_new", simple_generics = true)]
		public static Module create<T> (string name, Check<T>? check, PreCheck<T>? precheck, owned T user);

		/**
		 * Load a module from a string containg the module name and arguments.
		 *
		 * @param path the name or path to a module separated by LT_PATHSEP_CHAR and any arguments to the initialisation function of that module
		 */
		[CCode (cname = "panda_module_load")]
		public static Module load (LogProxy logger, string path);

		/**
		 * Increment reference count.
		 */
		[CCode (cname = "panda_module_ref")]
		public unowned Module @ref ();
		/**
		 * Decrement reference count.
		 */
		[CCode (cname = "panda_module_unref")]
		public void unref ();
	}

	/**
	 * A threading-safe wrapper to allow multiple assemblers to share a single data source.
	 */
	[CCode (cname = "struct panda_mux", ref_function = "panda_mux_ref", unref_function = "panda_module_unref")]
	[Compact]
	public class Mux {
		/**
		 * Get the number of assemblers created so far.
		 */
		public size_t child_count {
			[CCode (cname = "panda_mux_get_child_count")]
			get;
		}

		public LogProxy logger {
			[CCode (cname = "panda_mux_get_loggger")]
			get;
		}

		/**
		 * Open a pair of FASTQ files for multi-threaded assembled.
		 * @see Assembler.open
		 */
		[CCode (cname = "panda_mux_open")]
		public static Mux? open (string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);
		/**
		 * Create a new multiplexed data source from a sequence callback.
		 *
		 * The interface will guarantee that only one call will be made at a time to the data source or the logger. However, the interface makes no guarantees in which thread the call will be made. Furthermore, the logger may be call multiple times by different assembly processes (i.e., the logging messages from different sequences may be interleaved).
		 */
		[CCode (cname = "PandaMux", cheader_filename = "pandaseq-mux.h")]
		public Mux (owned NextSeq next, LogProxy logger);
		/**
		 * Create a new multiplexed reader for given to FASTQ streams.
		 * @see create_fastq_reader
		 */
		public Mux.fastq (owned BufferRead forward, owned BufferRead reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT);
		/**
		 * Create a new assembler using the multiplexer as it sequence source.
		 *
		 * The new assembler will draw sequences from the original source in a thread-safe way. Each assembler is not thread-safe. This means that, to use the interface correctly, one creates a sequence source, wraps it in a multiplexer, then creates an assembler for every thread. Each assembler should be accessed in only one thread. It may be advisable to create a single assembler and set its configuration, then copy the settings to subsequently created assemblers.
		 * @see Assembler.copy_configuration
		 */
		[CCode (cname = "panda_mux_create_assembler")]
		public Assembler create_assembler ();
		/**
		 * Create a new assembler using the multiplexer as it sequence source with a custom //k//-mer table size.
		 * @see Assembler.Assembler.kmer
		 */
		[CCode (cname = "panda_mux_create_assembler_kmer")]
		public Assembler create_assembler_kmer (size_t num_kmers);
		/**
		 * Increase the reference count on a multiplexer.
		 */
		[CCode (cname = "panda_mux_ref")]
		public unowned Mux @ref ();
		/**
		 * Attached a callback for every sequence that fails to have an overlap.
		 *
		 * This will be called when a sequence fails to have an overlap computed. This does not include sequences that are missing primers or sequences that are assembled and discarded by modules.
		 *
		 * Synchronisation is the resonsibility of the callee. This function must be re-entrant.
		 */
		[CCode (cname = "panda_mux_set_fail_alignment")]
		public void set_fail_alignment (owned FailAlign? handler);
		/**
		 * Decrease the reference count on a multiplexer.
		 */
		[CCode (cname = "panda_mux_unref")]
		public void unref ();
	}

	[CCode (cname = "struct panda_assembler", ref_function = "panda_assembler_ref", unref_function = "panda_assembler_unref")]
	[Compact]
	public class Overlaps {
		/**
		 * The longest overlap assembled so far.
		 */
		public size_t size {
			[CCode (cname = "panda_assembler_get_longest_overlap")]
			get;
		}

		/**
		 * Report the number of sequences that have been assembled with the overlap specified.
		 */
		[CCode (cname = "panda_assembler_get_overlap_count")]
		public long get (size_t overlap);
	}

	/**
	 * A set of sequence identifiers against which to match.
	 */
	[CCode (cname = "struct panda_idset", ref_function = "panda_idset_ref", unref_function = "panda_idset_unref")]
	[Compact]
	public class Set {

		/**
		 * Create a new, empty set.
		 */
		[CCode (cname = "panda_idset_new")]
		public Set ();

		/**
		 * Add a sequence identifier to a set.
		 */
		[CCode (cname = "panda_idset_add")]
		public void add (identifier id);
		/**
		 * Parse a sequence identifier and add it to the set.
		 * @return true on success
		 * @see identifier.parse_fail
		 */
		[CCode (cname = "panda_idset_add_str")]
		public bool add_str (string id, Tagging policy = Tagging.OPTIONAL, out IdFormat detected_format = null, out unowned string end = null);

		/**
		 * Check if a sequence identifier has been added to the set.
		 */
		[CCode (cname = "panda_idset_contains")]
		public bool contains (identifier id);

		/**
		 * Increase the reference count on a set.
		 *
		 * This is thread-safe.
		 */
		[CCode (cname = "panda_idset_ref")]
		public unowned Set @ref ();

		/**
		 * Decrease the reference count on a set.
		 *
		 * This is thread-safe.
		 */
		[CCode (cname = "panda_idset_unref")]
		public void unref ();
	}
	/**
	 * A transaction stream writer to improve output throughtput while using threads.
	 *
	 * This buffers writes to output into small transactions that are written in
	 * groups to an output source. This is mean to alleviate contention since each
	 * thread need not obtain an output lock for every write.
	 */
	[CCode (cname = "struct panda_writer", ref_function = "panda_writer_ref", unref_function = "panda_writer_unref")]
	[Compact]
	public class Writer {
		/**
		 * Open a file for writing.
		 * @param filename The file to write.
		 * @param bzip Write BZipped text rather than plain text.
		 */
		[CCode (cname = "panda_writer_open_file")]
		public static Writer? open_file (string filename, bool bzip);
		/**
		 * Create a new writer, backed by some target.
		 */
		[CCode (cname = "panda_writer_new")]
		public Writer (owned BufferWrite write);
		/**
		 * Create a new writer, backed by an open file.
		 */
		[CCode (cname = "panda_writer_new_file")]
		public Writer.file (owned GLib.FileStream file);
		/**
		 * Create a writer which discards all writes.
		 */
		[CCode (cname = "panda_writer_new_null")]
		public Writer.null ();
		/**
		 * Create a new writer, backed by standard error.
		 */
		[CCode (cname = "panda_writer_new_stderr")]
		public Writer.stderr ();
		/**
		 * Create a new writer, backed by standard output.
		 */
		[CCode (cname = "panda_writer_new_stdout")]
		public Writer.stdout ();

		/**
		 * A target write to be commited at the same time as this one.
		 *
		 * A writer may have a slave writer that will recieve a commit whenever
		 * {@link commit} is called on this writer.
		 */
		public Writer? slave {
			[CCode (cname = "panda_writer_get_slave")]
			get;
			[CCode (cname = "panda_writer_set_slave")]
			set;
		}

		/**
		 * Write a printf-like formatted string to the output.
		 */
		[CCode (cname = "panda_writer_append")]
		[PrintfFormat]
		public void append (string format, ...);
		/**
		 * Write a printf-like formatted string to the output.
		 */
		[CCode (cname = "panda_writer_append_v")]
		[PrintfFormat]
		public void append_v (string format, va_list va);

		/**
		 * Write a single character to the output.
		 */
		[CCode (cname = "panda_writer_append_c")]
		public void append_c (char c);
		/**
		 * Write a sequence identifier to the output.
		 */
		[CCode (cname = "panda_writer_append_id")]
		public void append_id (identifier id);
		/**
		 * End the current transaction and start another.
		 *
		 * This will consider the appending done so far to this writer to be a unit
		 * that can be passed to the output when necessary.
		 */
		[CCode (cname = "panda_writer_commit")]
		public void commit ();

		/**
		 * Force writing all buffered data to the output.
		 *
		 * This requires getting a lock and happens automatically under normal circumstances.
		 */
		[CCode (cname = "panda_writer_flush")]
		public void flush ();

		/**
		 * Increase the reference count on a writer.
		 *
		 * This is thread-safe.
		 */
		[CCode (cname = "panda_writer_ref")]
		public unowned Writer @ref ();
		/**
		 * Decrease the reference count on a writer.
		 *
		 * This is thread-safe.
		 */
		[CCode (cname = "panda_writer_unref")]
		public void unref ();

		/**
		 * Write an unassembled sequence to a FASTA file as a concatenated pair.
		 */
		[CCode (cname = "panda_output_fail", instance_pos = -1)]
		public void write_fail (Assembler assembler, identifier id, [CCode (array_length_type = "size_t")] qual[] forward, [CCode (array_length_type = "size_t")] qual[] reverse);

		/**
		 * Write an unassembled sequence to a FASTQ file as a concatenated pair.
		 */
		[CCode (cname = "panda_output_fail_qual", instance_pos = -1)]
		public void write_fail_qual (Assembler assembler, identifier id, [CCode (array_length_type = "size_t")] qual[] forward, [CCode (array_length_type = "size_t")] qual[] reverse);
	}

	/**
	 * Illumina sequence information from the FASTQ header
	 */
	[CCode (cname = "panda_seq_identifier", copy_function = "panda_seqid_copy", has_type_id = false, destroy_function = "")]
	public struct identifier {
		string flowcell;
		string instrument;
		int lane;
		string run;
		string tag;
		int tile;
		int x;
		int y;
		[CCode (cname = "panda_seqid_clear")]
		public identifier ();
		/**
		 * Parse an Illumina header
		 *
		 * @return the direction of the sequence (1 for forward, 2 or 3 for reverse) or 0 if an error occurs. Sequences from the Short Read Archive are always 1.
		 */
		[CCode (cname = "panda_seqid_parse")]
		public static int parse (out identifier id, string input, Tagging policy);
		/**
		 * Parse an Illumina header with failure information
		 *
		 * @param end the remainder of the string if parsing failed.
		 * @see parse
		 */
		[CCode (cname = "panda_seqid_parse_fail")]
		public static int parse_fail (out identifier id, string input, Tagging policy, out IdFormat detected_format, out unowned string end);
		/**
		 * Compare two Illumina headers
		 */
		[CCode (cname = "panda_seqid_equal")]
		public bool equal (identifier other);
		/**
		 * Write the Illumina header to a printf-like function
		 */
		[CCode (cname = "panda_seqid_xprint")]
		public void print (PrintfFunc func);
		/**
		 * Write an Illumina header for a sequence identifier to a file
		 */
		[CCode (cname = "panda_seqid_print")]
		public void to_file (GLib.FileStream file);
		/**
		 * Create an Illumina header for a sequence identifier
		 *
		 * The return string must not be freed and subsequent calls will obliterate the previously returned string.
		 */
		[CCode (cname = "panda_seqid_str")]
		public unowned string to_string ();
	}

	/**
	 * A //k//-mer and its position in the original sequence.
	 */
	[CCode (cname = "panda_kmer", has_type_id = false)]
	[SimpleType]
	public struct kmer {
		public size_t kmer;
		public size_t posn;
	}

	/**
	 * A single nucleotide with quality information
	 */
	[CCode (cname = "panda_qual", has_type_id = false)]
	public struct qual {
		/**
		 * The nucleotide
		 */
		Nt nt;
		/**
		 * The quality score as a PHRED score
		 */
		[CCode (cname = "qual")]
		char phred;
		/**
		 * Find the best offset of a small sequence in a large sequence.
		 * @param threshold the minimum log probability to match
		 * @param penalty the penalty to subtract from the probability for each base from the start of the sequence
		 * @param reverse if false, scan the sequence from start to finish, else, scan in the opposite direction
		 * @return 0 if the sequence is not found, or one more than the offset.
		 */
		[CCode (cname = "panda_compute_offset_qual")]
		public static size_t compute_offset (double threshold, double penalty, bool reverse, [CCode (array_length_type = "size_t")] qual[] haystack, [CCode (array_length_type = "size_t")] Nt[] needle);
		/**
		 * Convert the PHRED quality score to a log probability.
		 */
		public double log_probability {
			[CCode (cname = "panda_quality_log_probability")]
			get;
		}
		/**
		 * Convert the PHRED quality score to a probability.
		 */
		public double probability {
			[CCode (cname = "panda_quality_probability")]
			get;
		}
	}

	/**
	 * A reconstructed nucleotide
	 */
	[CCode (cname = "panda_result", has_type_id = false)]
	public struct result {
		/**
		 * The nucleotide
		 */
		public Nt nt;
		/**
		 * The quality score as a log probability
		 */
		[CCode (cname = "p")]
		public double log_probability;
		/**
		 * Convert the probability to a PHRED quality score.
		 */
		public int8 phred {
			[CCode (cname = "panda_result_phred")]
			get;
		}
		/**
		 * The quality score as a probability
		 */
		public double probability {
			get {
				return GLib.Math.exp (log_probability);
			}
		}
		/**
		 * Find the best offset of a small sequence in a large sequence.
		 * @param threshold the minimum log probability to match
		 * @param penalty the penalty to subtract from the probability for each base from the start of the sequence
		 * @param reverse if false, scan the sequence from start to finish, else, scan in the opposite direction
		 * @return 0 if the sequence is not found, or one more than the offset.
		 */
		[CCode (cname = "panda_compute_offset_result")]
		public static size_t compute_offset (double threshold, double penalty, bool reverse, [CCode (array_length_type = "size_t")] result[] haystack, [CCode (array_length_type = "size_t")] Nt[] needle);
	}

	/**
	 * A reconstructed sequence with meta information
	 */
	[CCode (cname = "panda_result_seq", has_type_id = false, destroy_function = "")]
	public struct result_seq {
		/**
		 * Number of uncalled bases in the sequence.
		 */
		public size_t degenerates;

		/**
		 * The original forward sequence
		 */
		[CCode (array_length_cname = "forward_length")]
		public qual[] forward;

		/**
		 * The number of nucleotides clipped from the forward sequence
		 */
		public size_t forward_offset;

		/**
		 * The sequence identification information
		 */
		public identifier name;

		/**
		 * Calculated quality score as the log of the geometric mean of the product of the Illumina quality scores of the included bases.
		 */
		public double quality;

		/**
		 * The reconstructed sequence with quality information
		 */
		[CCode (array_length_cname = "sequence_length")]
		public result[] sequence;

		/**
		 * The original reverse sequence
		 */
		[CCode (array_length_cname = "reverse_length")]
		public qual[] reverse;

		/**
		 * The number of nucleotides clipped from the reverse sequence
		 */
		public size_t reverse_offset;

		/**
		 * The overlap chosen.
		 */
		public size_t overlap;

		/**
		 * The probability of the overlap region being the correct one by the original estimation.
		 */
		public double estimated_overlap_probability;

		/**
		 * The first base in the result sequence in the overlap.
		 */
		public size_t overlap_offset {
			[CCode (cname = "PANDA_RESULT_OVERLAP_OFFSET")]
			get;
		}

		/**
		 * The first base in the forward sequence in the overlap.
		 */
		public size_t overlap_forward_offset {
			[CCode (cname = "PANDA_RESULT_OVERLAP_FORWARD_OFFSET")]
			get;
		}

		/**
		 * The first base in the reverse sequence in the overlap.
		 */
		public size_t overlap_reverse_offset {
			[CCode (cname = "PANDA_RESULT_OVERLAP_REVERSE_OFFSET")]
			get;
		}

		/**
		 * The number of mismatches in the overlap region.
		 */
		public size_t overlap_mismatches;

		/**
		 * The number of overlaps that were examined to determine the one finally used.
		 */
		public size_t overlaps_examined;

		/**
		 * Write an assembly to a FASTA file.
		 */
		[CCode (cname = "panda_output_fasta")]
		public bool write_fasta (Writer writer);
		/**
		 * Write an assembly to a FASTQ file.
		 */
		[CCode (cname = "panda_output_fastq")]
		public bool write_fastq (Writer writer);
	}

	/**
	 * The default number of locations in the //k//-mer look up table.
	 *
	 * When attempting to align the sequences, the {@link Assembler} will store the location of every //k//-mer in a table. If the same //k//-mer is present multiple times, only the first ones will be store until the table is full. If the sequences are highly repetitive, lost positions can prevent good alignments.
	 */
	[CCode (cname = "PANDA_DEFAULT_NUM_KMERS")]
	public const size_t DEFAULT_NUM_KMERS;

	/**
	 * Maximum length of a sequence
	 */
	[CCode (cname = "PANDA_MAX_LEN")]
	public const int MAX_LEN;

	/**
	 * Assemble a sequence from read pairs.
	 *
	 * This is normally {@link Assembler.next} while doing diffs, but it can be mocked out if needed.
	 */
	[CCode (instance_pos = 0.1, cname = "PandaAssemble")]
	public extern delegate unowned result_seq? Assemble (identifier id, [CCode (array_length_type = "size_t")] qual[] forward, [CCode (array_length_type = "size_t")] qual[] reverse);

	/**
	 * Get the next characters from an input stream.
	 *
	 * For assembly from an alternate source of data, this function reads more data from the stream.
	 * @param buffer the buffer to which to write the bytes
	 * @param read the number of bytes read into the buffer
	 * @return true if no error occurred
	 */
	[CCode (cname = "PandaBufferRead")]
	public delegate bool BufferRead ([CCode (array_length_type = "size_t")] uint8[] buffer, out size_t read);

	/**
	 * Write data to an output stream.
	 * @param buffer the buffer to write
	 */
	[CCode (cname = "PandaBufferWrite")]
	public delegate void BufferWrite ([CCode (array_length_type = "size_t")] uint8[] buffer);

	/**
	 * Handle a failed alignment
	 *
	 * This is called when an assembler fails to align a sequence because it can't compute a reasonable overlap.
	 * @param assembler The assembler that made the attempt
	 * @param id the sequence id of the failed pair
	 * @param forward the forward read
	 * @param reverse the reverse read
	 */
	[CCode (cname = "PandaFailAlign", has_type_id = false)]
	public delegate void FailAlign (Assembler assembler, identifier id, [CCode (array_length_type = "size_t")] qual[] forward, [CCode (array_length_type = "size_t")] qual[] reverse);

	/**
	 * A callback for iterating over the current modules.
	 * @param assembler the assembler which is being queried
	 * @param module the module selected
	 * @param rejected the number of sequences rejected by this module in the context of the current assembler
	 * @return true to continue iterating, false to stop
	 */
	[CCode (cname = "PandaModuleCallback")]
	public delegate bool ModuleCallback (Assembler assembler, Module module, size_t rejected);

	/**
	 * Get the next sequence pair.
	 *
	 * For assembly from a non-FASTQ text source, this function can provide the next sequence. The function must provide the sequences and metadata for assembly by modifing the values of its parameters.
	 * @param id the identifier information for the sequence pair
	 * @param forward the location of the parsed sequence data of the forward read.
	 * @param reverse the location of the parsed sequence data of the reverse read.
	 */
	[CCode (cname = "PandaNextSeq")]
	public delegate bool NextSeq (out identifier id, [CCode (array_length_type = "size_t")] out unowned qual[] forward, [CCode (array_length_type = "size_t")] out unowned qual[] reverse);

	/**
	 * Write a finsihed sequence to an appropriate place.
	 * @param sequence the sequence from assembly
	 */
	[CCode (cname = "PandaOutputSeq")]
	public delegate bool OutputSeq (result_seq sequence);

	[CCode (cname = "PandaPrintf", instance_pos = 0)]
	[PrintfFormat]
	public delegate void PrintfFunc (string format, ...);

	[CCode (cname = "panda_create_async_reader")]
	public static NextSeq create_async_reader (owned NextSeq next, size_t length);

	/**
	 * Create an object to read sequences from two character streams of FASTQ data
	 *
	 * @param forward the stream of forward characters, called every time new characters are required.
	 * @param reverse the stream of reverse characters, called every time new characters are required.
	 * @param logger the logging proxy to use during assembly.
	 * @param qualmin the quality to subtract from the incoming file (usually 33 or 64, depending on CASAVA version)
	 * @param policy method to handle unbarcoded sequences
	 */
	[CCode (cname = "panda_create_fastq_reader")]
	public static NextSeq create_fastq_reader (owned BufferRead forward, owned BufferRead reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT, owned BufferRead? index = null);

	/**
	 * The current module API version of the running library
	 */
	[CCode (cname = "panda_api_version")]
	public int get_api_version ();

	/**
	 * Get the number of worker threads that should be created given the number of processors in this system, if that can be determined.
	 */
	[CCode (cname = "panda_get_default_worker_threads")]
	public int get_default_worker_threads ();

	/**
	 * The current version string
	 */
	[CCode (cname = "panda_version")]
	public unowned string get_version ();

	/**
	 * Write an unassembled sequence to a FASTA file as a concatenated pair.
	 */
	[CCode (cname = "PANDA_FAIL")]
	public FailAlign? create_fail_writer (string file, bool append);

	/**
	 * Compare sequences assembled by two different assemblers.
	 *
	 * @param reader the source of the sequences.
	 * @param control the control assembly process.
	 * @param experiment the experiment assembly process.
	 * @param suppress_quality_diffs consider nucleotides that have different quality scores to be identical.
	 */
	[CCode (cname = "panda_diff")]
	public bool diff (NextSeq reader, Assemble control, Assemble experiment, bool suppress_quality_diffs);

	/**
	 * Compute log(1 - exp(p)) efficiently.
	 *
	 * See [[http://cran.r-project.org/web/packages/Rmpfr/vignettes/log1mexp-note.pdf|Mächler, 2012]].
	 */
	[CCode (cname = "panda_log1mexp")]
	public double log1mexp (double p);

	/**
	 * Open a file that might be uncompressed or compressed with gzip or bzip2.
	 */
	[CCode (cname = "panda_open_buffer")]
	public BufferRead? open_buffer (string file_name, LogProxy logger);

	/**
	 * Open a pair of FASTQ files.
	 *
	 * Compression is detected automatically.
	 *
	 * @param qualmin the value to strip from the quality scores. Usually 33 or 64, depending on CASAVA version.
	 */
	[CCode (cname = "panda_open_fastq")]
	public NextSeq? open_fastq (string forward, string reverse, LogProxy logger, uint8 qualmin = 33, Tagging policy = Tagging.PRESENT, string? index = null);

	/**
	 * Spawn threads and assemble sequences.
	 * @param threads the number of threads to spawn
	 * @param assembler the main assembler to use. If multiple threads are to be used, the configuration of this assembler will be copied to all the slave assemblers.
	 * @param mux the multiplexer to use. If null, no threads will be created. The provided assembler must be a product of this multiplexer.
	 * @param output the delegate that will write assembled sequences to where they belong.
	 */
	[CCode (cname = "panda_run_pool")]
	public bool run_pool (int threads, owned Assembler assembler, owned Mux? mux, owned OutputSeq output);

	/**
	 * Wraps an existing stream of reads and clips off reads that have the too-long overlap problem.
	 * @param inner the stream to wrap.
	 * @param forward the sequence to trim from the forward read.
	 * @param reverse the sequence to trim from the reverse read.
	 * @param skip whether to try to assemble sequences that don't contain a trim sequence.
	 * @param threshold a log probability threshold for cut-off alignment
	 */
	[CCode (cname = "panda_trim_overhangs")]
	public NextSeq trim_overhangs (owned NextSeq inner, [CCode (array_length = "size_t")] Nt[] forward, [CCode (array_length = "size_t")] Nt[] reverse, bool skip, double threshold);

	/**
	 * The current flags used be the assember to report errors. Some errors are always reported.
	 */
	[CCode (cname = "panda_debug_flags")]
	public Debug debug_flags;

	namespace StdArgs {
		/**
		 * The standard list of assembler-only arguments for PANDAseq binaries.
		 */
		[CCode (cname = "panda_tweak_assembler", array_length_cexpr = "panda_stdargs_length", array_length_type = "size_t")]
		public const Tweak.assembler? [] list;
		/**
		 * The algorithm selection switch (-A).
		 */
		[CCode (cname = "panda_stdargs_algorithm")]
		public const Tweak.assembler algorithm;
		/**
		 * The strip primers after switch (-a).
		 */
		[CCode (cname = "panda_stdargs_primers_after")]
		public const Tweak.assembler primers_after;
		/**
		 * The filter plugin loader (-C).
		 */
		[CCode (cname = "panda_stdargs_module")]
		public const Tweak.assembler module;
		/**
		 * The penalise primers if they are further from the start of the sequence (-D).
		 */
		[CCode(cname = "panda_tweak_assembler")]
		public const Tweak.assembler primer_penalty;
		/**
		 * The minimum length filter switch (-l).
		 */
		[CCode (cname = "panda_stdargs_min_len")]
		public const Tweak.assembler min_len;
		/**
		 * The maximum length filter switch (-L).
		 */
		[CCode (cname = "panda_stdargs_max_len")]
		public const Tweak.assembler max_len;
		/**
		 * The no N's switch (-N).
		 */
		[CCode (cname = "panda_stdargs_degenerates")]
		public const Tweak.assembler degenerates;
		/**
		 * The minimum overlap switch (-o).
		 */
		[CCode (cname = "panda_stdargs_min_overlap")]
		public const Tweak.assembler min_overlap;
		/**
		 * The maximum overlap switch (-O).
		 */
		[CCode (cname = "panda_stdargs_max_overlap")]
		public const Tweak.assembler max_overlap;
		/**
		 * The forward primer filter switch (-p).
		 */
		[CCode (cname = "panda_stdargs_forward_primer")]
		public const Tweak.assembler forward_primer;
		/**
		 * The reverse primer filter switch (-q).
		 */
		[CCode (cname = "panda_stdargs_reverse_primer")]
		public const Tweak.assembler reverse_primer;
		/**
		 * The threshold filter switch (-t).
		 */
		[CCode (cname = "panda_stdargs_threshold")]
		public const Tweak.assembler threshold;

		/**
		 * The standard argument handler for overhanging read pair trimmer.
		 *
		 * This is meant to wrap an existing arugment handler.
		 */
		[CCode (cname = "struct panda_args_hang", free_function = "panda_args_hang_free")]
		[Compact]
		public class HangArgs {
			/**
			 * Command line arguments for a pair of FASTQ files from Illumina.
			 */
			[CCode (cname = "panda_args_hang_args", array_length_type = "size_t")]
			public static Tweak.general? [] args ([CCode (array_length_type = "size_t")] Tweak.general? [] general_args);

			/**
			 * Create a new argument handler.
			 */
			[CCode (cname = "panda_args_hang_new", simple_generics = true)]
			public static HangArgs create<T> (owned T user_data, Tweak.GeneralHandler<T> tweak, Tweak.Opener<T> opener, Tweak.Setup<T> setup);

			/**
			 * Process the command line arguments.
			 */
			[CCode (cname = "panda_args_hang_tweak")]
			public bool tweak (char flag, string argument);

			/**
			 * Initialise the sequence stream.
			 */
			[CCode (cname = "panda_args_hang_opener")]
			public NextSeq? opener (LogProxy logger, out FailAlign? fail);

			/**
			 * Do additional assembly setup for the FASTQ argument handler.
			 */
			[CCode (cname = "panda_args_hang_setup")]
			public bool setup (Assembler assembler);
		}

		/**
		 * The standard argument handler for a pair of FASTQ files from Illumina.
		 */
		[CCode (cname = "struct panda_args_fastq", free_function = "panda_args_fastq_free")]
		[Compact]
		public class FastqArgs {
			/**
			 * Command line arguments for a pair of FASTQ files from Illumina.
			 */
			[CCode (cname = "panda_args_fastq_args", array_length_cexpr = "panda_args_fastq_args_length", array_length_type = "size_t")]
			public const Tweak.general? [] args;

			/**
			 * Create a new argument handler.
			 */
			[CCode (cname = "panda_args_fastq_new")]
			public FastqArgs ();

			/**
			 * Process the command line arguments for the FASTQ argument handler.
			 */
			[CCode (cname = "panda_args_fastq_tweak")]
			public bool tweak (char flag, string argument);

			/**
			 * Initialise the sequence stream for the FASTQ argument handler.
			 */
			[CCode (cname = "panda_args_fastq_opener")]
			public NextSeq? opener (LogProxy logger, out FailAlign? fail);

			/**
			 * Do additional assembly setup for the FASTQ argument handler.
			 */
			[CCode (cname = "panda_args_fastq_setup")]
			public bool setup (Assembler assembler);
		}
	}

	namespace Tweak {
		/**
		 * Process a command-line flag specified by the user.
		 * @param assembler the assembler to which to make the adjustments
		 * @param flag the command line flag specified
		 * @param argument the command line argument, or null if not set.
		 * @return whether the flag was parsed successfully
		 */
		[CCode (cname = "PandaTweakAssembler", has_type_id = false, has_target = false)]
		public delegate bool AssemblerHandler (Assembler assembler, char flag, owned string? argument);

		/**
		 * Process a command-line flag specified by the user.
		 * @param flag the command line flag specified
		 * @param argument the option passed specified with the flag, if requested.
		 * @param user_data the context
		 * Returns: whether the flag was parsed succesfully
		 */
		[CCode (cname = "PandaTweakGeneral", has_type_id = false, has_target = false, simple_generics = true)]
		public delegate bool GeneralHandler<T> (T user_data, char flag, string? argument);

		/**
		 * Create a sequence reader after argument parsing.
		 *
		 * This returns a sequence source and a failure handler so that assembly can proceed.
		 * @param user_data the context
		 * @param logger The logging proxy to use, if needed.
		 * @param fail the handler for any sequences which do not align, if desired.
		 * @param help if true, the help text will be displayed when the function exits.
		 * @return the sequence source, or null to indicate a failure
		 */
		[CCode (cname = "PandaOpener", has_type_id = false, has_target = false, simple_generics = true)]
		public delegate NextSeq Opener<T> (T user_data, LogProxy logger, out FailAlign? fail);

		/**
		 * Perform any modifications to the assembler after creation.
		 */
		[CCode (cname = "PandaSetup", has_type_id = false, has_target = false, simple_generics = true)]
		public delegate bool Setup<T> (T user_data, Assembler assembler);

		/**
		 * Describes a command line option that can be applied to an assembler.
		 */
		[CCode (cname = "panda_tweak_assembler", has_type_id = false)]
		public struct assembler {
			/**
			 * Construct a new list by combining existing lists.
			 * @param array The storage location of the array. If the array is null, it will be allocated. It must be in reallocable memory.
			 * @param additions The array whose items to copy.
			 */
			[CCode (cname = "panda_tweak_assembler_append")]
			public static void append ([CCode (array_length_type = "size_t")] ref assembler? []? array, [CCode (array_length_type = "size_t")] assembler? [] additions);

			/**
			 * Sort a list of arguments into flag order.
			 */
			[CCode (cname = "panda_tweak_assembler_sort")]
			public static void sort ([CCode (array_length_type = "size_t")] assembler? [] array);

			/**
			 * The command line option.
			 */
			char flag;
			/**
			 * The name of the argument as it appears in the help. If null, the argument is assumed to be boolean.
			 */
			string? takes_argument;
			/**
			 * The description of the option.
			 */
			string? help;
			/**
			 * The callback to make the appropriate changes to the assembler.
			 */
			AssemblerHandler setup;
			/**
			 * If the argument can be repeated. This is only considered if is not a boolean flag.
			 */
			bool repeatable;
		}

		/**
		 * Describes a command line option.
		 */
		[CCode (cname = "panda_tweak_general", has_type_id = false)]
		public struct general {
			/**
			 * Construct a new list by combining existing lists.
			 * @param array The storage location of the array. If the array is null, it will be allocated. It must be in reallocable memory.
			 * @param additions The array whose items to copy.
			 */
			[CCode (cname = "panda_tweak_general_append")]
			public static void append ([CCode (array_length_type = "size_t")] ref general? []? array, [CCode (array_length_type = "size_t")] general? [] additions);

			/**
			 * Sort a list of arguments into flag order.
			 */
			[CCode (cname = "panda_tweak_general_sort")]
			public static void sort ([CCode (array_length_type = "size_t")] general? [] array);

			/**
			 * The command line option.
			 */
			char flag;
			/**
			 * Whether the flag needs to be specified.
			 *
			 * This is used in the help output only.
			 */
			bool optional;
			/**
			 * The name of the argument as it appears in the help. If null, the argument is assumed to be boolean.
			 */
			string? takes_argument;
			/**
			 * The help information to display to the user.
			 */
			string help;
			/**
			 * If the argument can be repeated. This is only considered if is not a boolean flag.
			 */
			bool repeatable;
		}
		/**
		 * An assembler-specific argument value.
		 */
		[CCode (cname = "panda_tweak_assembler_opt", has_type_id = false, has_destroy_func = false)]
		public struct assembler_opt {
			public unowned assembler? tweak;
			public string? arg;
		}
		/**
		 * Read all the arguments and dispatch the general ones to the handler, and save the assembler ones.
		 *
		 * @param args the command line arguments
		 * @param assembler_args the assembler-specific arguments.
		 * @param general_args the non-assembler-specific arguments.
		 * @param tweak the call back for non-assembler-specific arguments.
		 * @param options the buffer to hold assembler-specific arguments.
		 * @param options_used the number of assembler-specific arguments found.
		 * @param args_unused the index of the first argument in the original array that is not consumed by the dispatcher
		 * @return if all arguments were dispatched successfully
		 */
		[CCode (cname = "panda_dispatch_args", simple_generics = true)]
		public bool dispatch<T> (string[] args, [CCode (array_length_type = "size_t")] assembler? [] assembler_args, [CCode (array_length_type = "size_t")] general? [] general_args, GeneralHandler<T> tweak, T user_data, [CCode (array_length_type = "size_t")] assembler_opt[] options, out size_t options_used, out int args_unused);

		/**
		 * Display help text for arguments.
		 *
		 * @param binary_name the executable name.
		 * @param assembler_args the assembler-specific arguments
		 * @param general_args the non-assembler-specific arguments
		 */
		[CCode (cname = "panda_args_help")]
		public void help (string binary_name, [CCode (array_length_type = "size_t")] assembler? [] assembler_args, [CCode (array_length_type = "size_t")] general? [] general_args);

		/**
		 * Parse command line arguments to in order to construct assemblers.
		 *
		 * This is meant to serve as a general framework for parsing command line arguments with maximum code reuse. There are two kinds of arguments: assembler-only and general. Assembler-only arguments need no context (i.e., they on modify the assembler based on their argument). General arguments might do this or they might be involved in selecting the sequence source.
		 *
		 * Lists of command line arguments are passed in and parsed. The opener is then called to open the data source and provide a sequence source. Then, an assembler and multiplexer will be created. All the assembler-only arguments and any additional setup are applied to the assembler. Any needed modules are loaded. Finally, the assembler and multiplexer are output, for use by the thread pool code.
		 * @param args the strings from the command line
		 * @param assembler_args descriptors of all the assembler-only command line arguments
		 * @param general_args descriptors of all the command line arguments userstood by the callbacks
		 * @param tweak a callback for every command line argument matching a general argument
		 * @param opener a callback to open the sequence source
		 * @param assembler_setup a callback to configure the assembler
		 * @param assembler the assembler constructed after argument parsing
		 * @param mux the multiplexer constructed after argument parsing
		 * @param threads the number of threads the user wishes to use
		 * @return whether command line parsing was successful and the output parameters have been populated
		 */
		[CCode (cname = "panda_parse_args", simple_generics = true)]
		public bool parse_args<T> (string[] args, [CCode (array_length_type = "size_t")] Tweak.general? [] general_args, [CCode (array_length_type = "size_t")] Tweak.assembler? [] assembler_args, GeneralHandler<T> tweak, Opener<T> opener, Setup<T> assembler_setup, T user_data, out Assembler? assembler, out Mux? mux, out int threads, out OutputSeq output);

		/**
		 * Parse args, but for doing a diff run.
		 *
		 * @param args the strings from the command line
		 * @param assembler_args descriptors of all the assembler-only command line arguments
		 * @param general_args descriptors of all the command line arguments userstood by the callbacks
		 * @param tweak a callback for every command line argument matching a general argument
		 * @param opener a callback to open the sequence source
		 * @param assembler_setup a callback to configure the assembler
		 * @param out_control_assembler the control (left-side) assembler constructed after argument parsing
		 * @param out_experimental_assembler the experiment (right-side) assembler constructed after argument parsing
		 * @param out_next the sequence reader
		 * @param out_suppress_quality_diffs whether to show differences in quality scores
		 * Returns: whether command line parsing was successful and the output parameters have been populated
		 */
		[CCode (cname = "panda_diff_parse_args", simple_generics = true)]
		public bool panda_diff_parse_args<T> (string[] args, [CCode (array_length_type = "size_t")] Tweak.general? [] general_args, [CCode (array_length_type = "size_t")] Tweak.assembler? [] assembler_args, GeneralHandler<T> tweak, Opener<T> opener, Setup<T> assembler_setup, T user_data, out Assembler? control_assembler, out Assembler? experimental_assembler, out NextSeq next, out bool suppress_quality_diffs);

		/**
		 * Parse a list of comma separated separated key=value keys.
		 *
		 * @param str the string containing the arguments
		 * @param key_parsed invoked for each key-value pair.
		 * @return whether parsing was successful.
		 */
		[CCode (cname = "panda_parse_key_values")]
		public bool parse_key_values (string? str, KeyParsed key_parsed);

		/**
		 * Process a key-value pair.
		 *
		 * Returns: whether processing was successful.
		 */
		[CCode (cname = "PandaKeyParsed", has_type_id = false)]
		public delegate bool KeyParsed (string key, string @value);
	}
}
